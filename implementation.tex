\section{Implementation} \label{sec:implementation}

Our implementation (written in Java) includes five components: regression simulator, test-rule correlation, request-record, test selection,
and test augmentation. To simulate regression in access control policies, 
we used three types of mutants injected in the policies; the first one
is RMR (Rule Removal), RA (Rule Addition), and RDC (Rule Decision Change)
mutants. The regression simulator analyzes a policy and injects one
of such changes. For RMR, given a randomly selected rule in a policy $P$,
the regression simulator removes the rule. For CRE,
given a randomly selected rule in a policy $P$, the regression simulator changes
the decision of the rule.
For $RA$, the regression simulator adds a randomly generated
rule with random attributes collected from $P$ in a random place.
The simulator can inject more than one type of changes to $P$ for simulating
regression on $P$.

For test selection based on mutation analysis technique,
our test test-rule correlation mutates a given policy using CRE
, executes all of test cases for each mutated policy, and monitors changed
behaviors by comparing test results of the test cases with an original policy or its mutated policy.
The component also automatically compares the testing results (on the policy and the mutated
policies) and logs killed mutant information if the results are inconsistent. We use
such killed mutant information for rule-test correlation.
For test selection based on coverage analysis technique,
we execute  all of test cases once and monitors
which rules are evaluated for each test case execution.We use such
coverage information for rule-test correlation.

For the test selection based on recorded request evaluation,
the request-record component records all requests issued by test cases and evaluated rules in a policy.

For our first two techniques, the test selection component requires change impact analysis to
show changed policy behaviors of two versions of policies.
The implementation leverages an existing access control policy verification tool called Margrave~\cite{fisler05:verification}. Margrave is a tool suite for analyzing access control policies written in XACML.
Given two versions of policies, $P$ and $P'$, 
our implementation uses the generic APIs of Margrave to
print out all the policy changes with their corresponding changed decisions in a summarized format.
Our first two techniques analyze the results of Margrave and
find which rules $R_i$ impacted by policy changes. We then find all of test cases $R_t$
impacted by $R_i$.

For the test selection based on recorded request evaluation,
the component does not require change impact analysis. The test selection
component log recorded requests to reveal different evaluated decision against $P$ and $P'$.

The test argumentation component compares
not-covered policy behaviors $r_1$s (i.e., represented by requests) with requests $r_2$s
issued from existing test cases. The test argumentation computes
similarity between $r_1$ and $r_2$ to decide applicability of modification for test
argumentation. Given recommended test cases with high similarity score,
we manually modify the test cased to cover not-covered policy behaviors. 
If not applicable for modification, the component
generates a test cases to issue such requests to cover not-covered policy behaviors. 



