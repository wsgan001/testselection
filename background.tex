
  
\section{Background}
\label{sec:background}
\subsection{Policy-based Software Systems: PEP-PDP separation}
Policy-based software systems are regulated by access control policies that specify the different actions that subjects are allowed to perform on system resources. 
The policy is enforced by one or multiple Policy Enforcement Points (PEP) at the application level. A given PEP receives a subject access request and 
sends it to a Policy decision Point (PDP) that evaluates access control requests against policy rules. The evaluation process involves resolving all the rules in the policy. 
Current access control implementations follow a design strategy that separates between the PEP and the PDP, this separation is advocated mainly for two reasons:
\begin{itemize}
\item Specifying the policy independently from the program enables to save time, cost and effort during the maintenance phase since developers are not required 
to update the application code at each policy update.
\item When the policy is not hard-coded into the application, it can be specified in a standardized language and transported through many different systems platforms.
\end{itemize}
Access control policies can be specified in many languages like EPAL \cite{epal} or XACML \cite {oasis05:xacml}. 
In this paper, we consider XACML polices described in Section~\ref{sec:xacmlpolicies}.


\subsection{XACML Policies} \label{sec:xacmlpolicies}
This section describes the background in the field of XACML policies, policy models, and regression testing.

\begin{figure}[t]
    \centering
        \includegraphics[width=3.7in]{example_policy.eps}
        \vspace{-5pt}
    \caption{\label{fig:example}An example policy specified in XACML}
    \vspace{-10pt}
%    \vspace{+3pt}
\end{figure}
%
%\begin{figure*}[t]%{t}
%%\begin{figure}[firstnumber=100]
%\begin{CodeOut}
%%\tiny % Too samll
%\begin{alltt}
% 
% 1 <Policy PolicyId="\textbf{Library Policy}" RuleCombAlgId="\textbf{Permit-overrides}">
% 2  <Target/>
% 3    <Rule RuleId="\textbf{1}" Effect="\textbf{Permit}">
% 4      <Target>
% 5        <Subjects><Subject> \textbf{BORROWER} </Subject></Subjects>
% 6        <Resources><Resource> \textbf{BOOK} </Resource></Resources>
% 7        <Actions><Action> \textbf{BORROWERACTIVITY} </Action></Actions>
% 8      </Target>
% 9	    <Condition>
%10        <AttributeValue> \textbf{WORKINGDAYS} </AttributeValue>
%11      </Condition>
%12    </Rule>
%13    <Rule RuleId="\textbf{2}" Effect="\textbf{Deny}">
%14      <Target>
%15        <Subjects><Subject> \textbf{BORROWER} </Subject></Subjects>
%16        <Resources><Resource> \textbf{BOOK} </Resource></Resources>
%17        <Actions><Action> \textbf{BORROWERACTIVITY} </Action></Actions>
%18      </Target>
%19	    <Condition>
%20        <AttributeValue> \textbf{HOLIDAYS} </AttributeValue>
%21      </Condition>
%22    </Rule>
%23    <Rule RuleId="\textbf{3}" Effect="\textbf{Permit}">
%24      <Target>
%25        <Subjects><Subject> \textbf{SECRETARY} </Subject></Subjects>
%26        <Resources><Resource> \textbf{BOOK} </Resource></Resources>
%27        <Actions><Action> \textbf{FIXBOOK} </Action></Actions>
%28      </Target>
%29	    <Condition>
%30        <AttributeValue> \textbf{MAINTENANCEDAY} </AttributeValue>
%31      </Condition>
%32    </Rule>
%33      <!-- A final, "fall-through" rule that always Denies -->
%34    <Rule RuleId="\textbf{FinalRule}" Effect="\textbf{Deny}"/>
%35 </policy>
%\end{alltt}
%\end{CodeOut}
%\vspace*{-3.0ex} \caption{An example policy specified in XACML}
% \label{fig:example}
%\end{figure*}

XACML (eXtensible Access Control Markup Language)~\cite{oasis05:xacml} is a language specification standard
%designed by OASIS.
published by the Organization for the Advancement of Structured Information Standards (OASIS).
An XACML access control specification consists of a policy set and a policy combining algorithm.
XACML supports various policy models such as Role Based Access Control (RBAC)~\cite{anderson04:rbacxacml,ferraiolo01:proposed} and Organization-Based Access 
Control (OrBAC)~\cite{kalam03:orBac}. For RBAC and OrBAC, various job functions are associated to roles (e.g., staff or employee) that a user possesses. 
Permissions or denials to take an action on certain objects are assigned to specific roles (instead of users). OrBAC supports 
extra features such as role, activity (i.e., action), and view (i.e., object) hierarchy.
Figure~\ref{fig:example} is an OrBAC policy example where 
roles such as ``Secretary'' and ``Borrower'' are associated with subject attributes and policy decisions are made through 
specific roles.

Let $Conditions$ be the set of the environmental context
such as working days or holidays, a file size, and a user's task authorization level. 
Let $S$, $O$, $A$, and $C$ denote all the subjects,
objects, actions, and  $Conditions$, respectively, in an access control system.

An XACML policy consists of a \Intro{policy set}, which consists
of \Intro{policy sets} and \Intro{policies}. A \Intro{policy} consists
of a sequence of \Intro{rules}, each of which
specifies under what conditions $C$ subject $S$ is allowed or denied
to perform action $A$ (e.g., read) on certain object (i.e., resources) $O$ in a system.

A rule $R$ is of the following form:
\begin{center}
$R$ $\subseteq$ $S$ $\times$ $A$ $\times$ $O$ $\times$ $C$ $\longrightarrow$ $Dec$
\end{center}
where $Dec$ denotes a decision, which is either permit or deny.
A user's request is evaluated against a policy.
A request matches with a rule if the request satisfies the rule's
attributes. Then the rule's decision can be returned.
Formally, a request $Q$ in the following form matches $R$:
\begin{center}
$Q$ $\subseteq$ $S_q$ $\times$ $A_q$ $\times$ $O_q$ $\times$ $C_q$ where $S_q$ $\subseteq$ $S$, $A_q$ $\subseteq$ $A$, $O_q$ $\subseteq$ $O$, and $C_q$ $\subseteq$ $C$.
\end{center}


More than one rule in a policy may be applicable to a given request.
The \Intro{rule combining algorithm} is used to combine multiple
rule decisions into a single decision. There are four standard rule
combining algorithms: \CodeIn{deny-overrides}, \CodeIn{permit-overrides}, \CodeIn{first
applicable}, and \CodeIn{only-one-applicable}. The
\Intro{deny-overrides algorithm} returns \CodeIn{Deny} if any rule
evaluation returns \CodeIn{Deny} or no rule is applicable. The
\Intro{permit-overrides algorithm} returns \CodeIn{Permit} if any
rule evaluation returns \CodeIn{Permit}. Otherwise, the algorithm
returns \CodeIn{Deny}.
The \Intro{first-applicable algorithm} returns whatever the
evaluation of the first applicable rule returns. The
\Intro{only-one-applicable} algorithm returns the decision of the only
applicable rule if there is only one applicable rule, and returns
error otherwise.

Figure~\ref{fig:example} shows a policy specified
in XACML. The policy consists of three XACML rules used in our real-life library access
control policy subject, called $LMS$~\cite{mouelhi09:tranforming}.
Note that we simplified XML formats to reduce
space for this example.
Lines 3-12 describe a rule that \CodeIn{borrower} is permitted to \CodeIn{borroweractivity} (e.g., borrowing books) \CodeIn{book} in \CodeIn{working days}.
Lines 13-22 describe a rule that \CodeIn{borrower} is denied to \CodeIn{borroweractivity} \CodeIn{book} in \CodeIn{holidays}.
Lines 23-32 describe a rule that \CodeIn{secretary} is permitted to \CodeIn{fixing} for \CodeIn{book} in \CodeIn{maintenance day}.
As these rules are combined using the permit-overrides algorithm, the \Intro{permit-overrides algorithm} returns the \CodeIn{Permit} if
 a request matches at least one of rules with permit decisions. For example, if rules 2 and 3 are applicable to a request, the decision
evaluated from rule 3 is given higher priority than that of rule 2.


\subsection{Regression Testing}
Software testing \cite{Myers:1979:AST:539883} refers to the activity of generating Tests Cases to verify the conformity of output results provided by a 
program to the expected output that meets its functional and non functional requirements. With the increasing complexity of software systems, 
this activity is gaining more and more interest in the research field and aiming to establish a trade-off between cost, time and quality. 
%%%%link%%%%

Software is subject to changes that occur at the design stage or in later stages at the deployment or maintenance phases. These changes are 
usually supposed to meet changes in the requirements or to overcome errors that can be detected in later stages of software life cycle. 
Regression testing refers to the research field that is interested in retesting the system to verify that the new changes have not altered 
the initial system behavior. As highlighted by Rothermel et al. in \cite{Rothermel:1996:ART:235681.235682}, regression testing is defined like the 
following: 
``Given a program $P$, a modified version $P'$, and a set $T$ of test cases used previously to test $P$, regression analysis and testing 
techniques attempt to make use of a subset of $T$ to gain sufficient confidence in the correctness of $P'$ with respect to behaviors from $P$ retained 
in $P'$''.

The main objectives of regression testing is to reduce the costs from rerunning initial test cases and to maximize the capability of 
selected tests to detect potential errors that may be induced by changes.
%\subsubsection{Regression testing: Test selection and augmentation}
%Regression test selection techniques involves two issues:
%\begin{itemize}
%\item The first issue is the regression test selection problem which aims at minimizing the number of tests that have to be considered 
%Rothermel et al. have provided in their work a survey on techniques that have been used in this field. 
%The regression test selection technique is called safe when the selected tests among the initial test suite enable to detect 100\% of the faults.
%\item The second aspect is test-suite augmentation which checks the adequacy of existing tests for the incoming changes
%and aims at adding new tests to the initial Test Suite to cover introduced modifications.
%\end{itemize}
%\subsubsection{Regression testing in the context of software policy-based systems}

To the best of our knowledge, there is no prior research work on regression testing that considers policy changes in policy-based software systems. 
To help developers reduce cost in testing such systems, we propose novel test selection and augmentation approach. 
%We next describe our regression testing by policy changes.
%while existing work (e.g., \cite{Rothermel:1996:ART:235681.235682})
%considers only program changes.
%\textbf{Regression testing in the context of software policy-based systems.}
%In this paper, we consider regression testing in the context of policy-based software systems.
In order to test policy-based software system, we deploy test cases that trigger the rules in the policy.
Our approach selects test cases by verifying that the changed parts of 
the policy do not reveal unexpected behaviors in a given system.
Whenever a policy $P$ is updated to a new policy $P'$,
existing test cases impacted by the policy changes need to be tested to validate that the policy changes do not introduce a negative impact on the initial implementation of a system.
\FixJeeHyun{The figure \ref {} illustrates the overall scenario of regression testing applied to policy-based software systems\\
ADD schema}





